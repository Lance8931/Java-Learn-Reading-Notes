# 卷一 第五章 继承(1)

## 5.1 类、超类和子类

”is-a“ 关系是继承的一个明显特征。即经理也是一名雇员。

### 5.1.1 定义子类

关键字**extends**表示继承。

该关键字表明正在构造的新类派生于一个已存在的类。

已存在的类：超类（superclass）、基类（base class）、父类（parent class）

新类：子类（subclass）、派生类（derived class）、孩子类（child class）

在通过扩展超类定义子类的时候，仅需要指出子类域超类的不同指出。所以在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

### 5.1.2 覆盖方法

对于超类中的有些方法对于子类并不一定适用，所以在子类中需要提供一个新的方法来覆盖（override）超类中的方法。

子类的方法不能够直接地访问超类的私有域，但超类有这个私有域的get公有方法。此时，我们希望调用超类的该方法，而不是当前类的相同这个方法。为此可以使用特定的关键字**super**解决这个问题。```super.getSalary();```

注：super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的**特殊关键字**。

在子类中可以增加域、增加方法或覆盖超类的方法，但是绝对不能删除继承的任何域和方法。

### 5.1.3 子类构造器

由于子类的构造器不能访问超类的私有域，所以必须利用超类的构造器对这部分私有域进行初始化，所以我们可以通过**super**实现**对超类构造器的调用**，同时super调用构造器的语句必须是**子类构造器的第一条语句**。



```java
Manager boss = new Manager("Carl",8000);// Manager是Employee的子类，并重写了getSalary()方法
Employee[] staff = new Employee[3];
staff[0] = boss;
staff[1] = new Employee("Tom",4000);
staff[2] = new Employee("Jack",3000);
for (Employee e : staff)
    System.out.println(e.getName() + " " + e.getSalary())
```

​	请注意，尽管这里将e声明为Employee类型，但实际上e既可以引用Employee类型的对象，也可以引用Manager类型的对象。当e引用Employee对象时，e.getSalary()调用的是Employee类中的getSalary方法；当e引用Manager对象时，e.getSalary()调用的是Manager类中的getSalary方法。虚拟机直到e实际引用的对象类型，因此能够正确地调用相应的方法。

​	一个对象变量(例如，变量e)可以**指示多种实际类型**的现象称为**多态**（polymorphism）。在**运行时**能够**自动地选择调用哪个方法**的现象称为**动态绑定**（dynamic binding）



### 5.1.4 继承层次

继承并不仅限于一个层次。

由一个公共超类派生出来的所有类的集合被称为**继承层次**。

在继承层次中，从某个特定的类**到其祖先**的路径被称为该类的**继承链**。



### 5.1.5 多态

有一个用来判断是否应该设计为继承关系的简单规则，就是**“is-a”**规则，它表明子类的每一个对象也是超类的对象。

“is-a”规则的另一种表述法是*置换法则*。它表明程序中出现超类对象的任何地方都可以用子类对象置换。例如，可以将一个子类的对象赋给超类变量。所以，在Java中，**对象变量是多态的**。



### 5.1.6 理解方法调用

假设要调用x.f(args)，隐式参数x声明为类C的一个对象。那么，在对象上应用方法调用如下：

1. **编译器查看对象的声明类型和方法名。**假设调用x.f(args)，且隐式参数x声明为C的对象。此时，可能存在多个名字为f，但参数类型不一样的方法。例如，f(int)和f(String)。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法(超类的私有方法不允许访问)。至此，编译器已获得所有可能被调用的候选方法。
2. **编译器将查看调用方法时提供的参数类型。**如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为*重载解析*。
3. 如果是**private方法、static方法、final方法或者构造器**，那么编译器将可以准确地知道应该调用哪个方法，这种调用方法称为*静态绑定*。与此相反的，调用的方法**依赖于**隐式参数的**实际类型**，并且在**运行时**实现动态绑定。
4. **当程序运行，并且采用动态绑定调用的方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法**。假设，x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类C中寻找f(String)，以此类推。