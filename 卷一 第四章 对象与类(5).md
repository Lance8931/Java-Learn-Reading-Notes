# 卷一 第四章(5)

## 4.6 对象构造

### 4.6.1 重载

重载定义：**多个方法有相同的名字、不同的参数**  

重载解析：编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。  

1. Java允许重载任何方法。

2. 方法的签名(signature)是指完整的方法名以及参数类型，用于完整的描述一个方法。但是返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同但是返回不同类型值的方法。例如：

   ```java
   indexOf(int);
   indexOf(int, int);
   indexOf(String);
   indexOf(String, int);
   ```

### 4.6.2 默认域初始化

1. 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋值为默认值：数值为0、布尔值为false、对象引用为null。
2. 没有对类的域进行初始化，这并不是一个良好的编程习惯。

### 4.6.3 无参数的构造器
1. 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器会将所有的实例域设置为默认值。即数值为0、布尔值为false、对象引用为null。
2. 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法，编译不通过。
3. 当且仅当**类没有提供任何构造器**的时候，系统才会提供一个**默认**的构造器。

### 4.6.4 显式域初始化
1. 可以在类定义中，直接将一个值赋给任何域

2. 在执行构造器**之前，先执行赋值操作**。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方法特别有用。

3. 初始值不一定是常量值，可以是一个计算表达式或者一个方法。例如以下方法对实例域用静态方法进行初始化。

   ```java
   calss Employee {
       private static int nexId;
       private int id = assignId();
       private static int assignId(){
           int r = nextId;
           nextId++;
           retrun r;
       }
   }
   ```

### 4.6.5 参数名
1. 在编写构造器时，常常将参数用单个字符命名，这样做不利于代码理解。所以可以在参数前几个前缀“a”。

   ```java
   // 以下示例不利于代码阅读
   public Employee(String n, double s){
       ...
   }
   
   // 应改为：
   public Employee(String aName, double aSalary){
       ...
   }
   ```

2. 基于一个这样的事实：参数变量用相同的名字会将实例域屏蔽起来。所以，如果将参数命名为salary，那么salary将引用这个参数，而不是实例域，但是可以使用**this.salary**的形式访问实例域。例如：

   ```java
   public Employee(String name, double salary){
       this.name = name;
       this.salary = salary;
   }
   // this指示隐式参数，也就是所构造的对象
   ```

### 4.6.6 调用另一个构造器

如果构造器的**第一个语句形如this(...)**，这个构造器将调用同一个类的另一个构造器。  

### 4.6.7 初始化块

1. 初始化块为第三种初始化数据域的方法。前两种为：在构造器中设置值；在声明中赋值。
2. 首先运行**初始化块**，然后才运行**构造器**的主体部分。
3. 使用**静态**的初始化块来对**静态域**进行初始化。在**类的第一次加载**的时候，将会进行静态域的初始化。所有静态初始化语句以及静态初始化块都将依照类定义的顺序执行。

##### 调用构造器的具体处理步骤：

1. 所有数据域被初始化为默认值（0，false或null）
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
4. 执行这个构造器的主体

### 4.6.8 对象析构和finalize方法

1. 在C++的析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不予要人工回收内存，所以Java**不支持**析构器。
2. 可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器**清除对象之前**调用。